
Update Version!

```{r}
library(readxl)
library(tidyverse)

d1 <- readRDS(file = "P:/Methoden/02_R_Pakete/eatRep/Outputstruktur/report2_outputs/03_mig_verschachtelt.rds")

## Verschachtelung nicht so schlimm bis jetzt, auf niedrigster Ebene muss es ja hiermit klappen.

eatRep_dat <- d1[[1]][[1]][[1]]


```

```{r data_prep}


merge_data <- function(dat){

  dat$plain <- NULL
  
dat$group_estimates <- dat[["group"]] %>%
  left_join(., dat[["estimate"]], 
            by = "id")

dat$comp_estimates <- dat[["comparisons"]] %>%
  left_join(., dat[["estimate"]], 
            by = "id")

return(dat)
}


d1$estimate <- d1$estimate %>%
  dplyr::filter(parameter != "Ncases")


plot_dat <- merge_data(d1)


```


```{r plot_lines}

  ## Manual filtering can be done in the group - list element, write vignette

## acutally, I only need this for significances: 
plot_line <- plot_dat$comp_estimates %>%
  pivot_longer(cols = starts_with("unit"), 
               names_to = "unit", 
               values_to = "group") %>%
  left_join(., 
            plot_dat$group_estimates, 
            join_by(group == id), 
            suffix = c("_comp", "_group"))  %>%
      filter(TR_BUNDESLAND == "Berlin", comparison == "trend", !is.na(gy)) %>%
  mutate(line_sig = ifelse(p_comp < 0.5, "solid", "dotted")
         ) %>%
  filter(id %in% c("comp_194", "comp_195", "comp_278", "comp_279")) %>%
  group_by(id) %>%
  mutate(trend = paste(year[1], year[2], sep = "_")) %>%
  ungroup()
  ## be careful not to select the wide trend!


ggplot(plot_line, 
     mapping = aes(
    x = year,
    y = est_group, 
    group = id,
    linetype = line_sig
        )) + 
  ggplot2::geom_line() + 
  geom_point() +
  ggbrace::stat_brace(aes(group = trend), 
                      linetype = "solid", 
                      width = 0.02) ## use some multiplicative value here? How is it defined currently? I draw them directly on the y-axis, but probably not necessary?
  
## maybe use stat_bracetext for labels? 



```



```{r}




## Ok, so now the data format is quite good already. I'd need some way to set in the groups into the unit columns. But why not do it later in the end, when the plotting is done, and work as long as possible with the groups. 
## So the group specific information are saved in the groups, and can be extracted later on.
## Maybe I can Work with a group-var for ggplot, so I don't have to pull the data into wide format and stay within this format? 

# Big part of the data preperation before was to fill up and rename columns ..., not necessary in that extend anymore.

## Because that takes out some of the complexity, and we can just merge in the end?
## Possible problem: Harder to understand the data frame outputs. But not that bad? 
## Maybe it will be possible to just name the depVar one is interested in, or even prepare the data before?
## Maybe write own class for ouptut, would make specific print functions possible. 
##################################
## Prepare plot building blocks ##
##################################
## So, for the plots I needed special columns to some part. They can be deducted from the groups. So for the lineplots at least, there shouldn't be much more necessary to do. 
## So actually, prep_data() not necessary anymore? 
## deprecate! 


## Vorgehen: 
## Neue Funktion zur Datenaufbereitung (eher nur intern)
## Wird dann einfach am Anfang von jeder Plot-Funktion angewendet. Dann mal die plot_line Geschichte durchgehen. 
## Version hochsetzen, Mail schreiben, wo alte Version noch drinsteht, und in newsletter packen. 


## seperate_plot_var: Variable to split plots. Mainly by state. 

## Years are filtered. 

# So the first part of the plot_line function is still data preperation. Propably doesn't make that much sense to split the functions up. 


## Plotting lines: 
## Year start and year end









## Okay, so maybe build dataframe trend related, so every trend has a start and an end point. I need this for the split lineplots anyways. 
## also, dont put all columns at the end, only the line_sig, point_sig ...

## each line in comp_estiamte is a trend from one year to another. 



## How to get the significances here? They are in comp_estimates.
## Okay, so the problem now is, that I actually need new columns for the respective estiamtes. 
## To stay as flexible as possible, add the needed significances as extra column. 




## Okay, that actually feels a lot more natural!




## Add group-readable column:
my_dat[["group"]] <- my_dat[["group"]] %>%
  unite("readable", bundesland, geschlecht, dezh, jahr, sep = "_", remove = FALSE)

# Build nested data tibbles -------------------------------------------------------------

## fills in the specific row describing the group in each cell. 
fill_groups <- function(dat) {
  dat %>%
    mutate(across(starts_with("unit"), ~
      map(.x, ~ ifelse(str_detect(.x, "^group"),
        yes = list(my_dat[["group"]] %>% filter(group %in% .x)),
        no = ifelse(str_detect(.x, "^comp"),
          yes = list(dat %>% filter(comp_id %in% c(.x))),
          no = list(tibble())
        )
      ))))
}

## fills in the specific row describing the comparison in each cell. 
fill_comparison <- function(dat) {
  dat_res <- dat %>%
    mutate(across(starts_with("unit"), ~
      map(.x, ~ ifelse(
        ncol(.x[[1]]) == 4,
        yes = list(fill_groups(.x[[1]])),
        no = list(.x[[1]])
      ))))%>%
    mutate(across(starts_with("unit"), ~
                    map(.x, ~ ifelse(
                      "unit_1" %in% colnames(.x[[1]]) ,
                      yes = list(unnest(.x[[1]], cols = c(unit_1, unit_2))),
                      no = list(.x[[1]])
                    ))))
  return(dat_res)
}


nested_data <- fill_groups(my_dat[["comparisons"]]) %>%
  fill_comparison %>%
  unnest(cols = c(unit_1, unit_2)) %>%
  left_join(my_dat[[3]], join_by(comp_id==id))  # add estimates

names(nested_data$unit_1) <- my_dat[[1]]$unit_1
names(nested_data$unit_2) <- my_dat[[1]]$unit_2

# Now we have nested tibbles

# Next build a human readable output from the nests. 

# 1. Go through all tibble-rows.
# 2. Check if list entry is a tibble with 6 columns. In this case, we are at the highest level, and there are no further nestings. Extract the readables and paste them together.
# 3. If there are 4 columns, there are nested columns. Go Back to Step 1.

paste_comp <- function(comp_1, comp_2) {
  paste0(
    "(",
    comp_1,
    " - ",
    comp_2,
    ")"
  )
}

extract_readables <- function(dat) {
  readables <- lapply(
    1:nrow(dat),
    function(x) {
      ifelse(ncol(dat$unit_1[[x]]) == 11,
        yes = paste_comp(dat$unit_1[[x]]$readable, dat$unit_2[[x]]$readable),
        no = paste_comp(extract_readables(dat$unit_1[[x]]), extract_readables(dat$unit_2[[x]]))
      )
    }
  )
  
  return(unlist(readables))
}

nested_data$readable <- extract_readables(nested_data)

# Extract specific output  ------------------------------------------------
## Let's say I want to extract all group Values and all crossDiff_of_groupDiffs. 
## We can build seperate data-frames which only contain the necessary information. 

output_2 <- nested_data %>%
  unnest(cols = c(unit_1, unit_2), 
         names_sep = "_")

## Unnesting everything at once leaves it all over the place, so probably not the best!
## Rather, filter first and then build more consciously: 

output_3 <- nested_data %>%
  filter(comp_type == "crossDiff_of_groupDiff") %>%
  unnest(cols = c(unit_1, unit_2), 
         names_sep = "->") 

output_4 <- unnest(output_3, cols = colnames(output_3)[output_3 %>% map_lgl(is.list)], 
         names_sep = ":") 

View(output_4)

## This could be cleaned up more and saved as excel, if a sortable output is needed. In other cases it might be enough to output only the readable column and the estimate. 


## Group values have already been merged and can just be put out:
my_dat[["group"]]



# Formated R-Output -------------------------------------------------------
# Just started to play around with building a R-internal output

library(crayon)
## Different group-options, just provide the column you want to group for. 

extract_results <- function(dat, comp_type){
  filtered_dat <- dat %>% 
    filter(comp_type %in% comp_type)

  cat("Summary/n/n")
  for(i in 1:nrow(filtered_dat)){
    cat(green("Comparison: ", filtered_dat$readable[i], "/n/n"))
    print(filtered_dat[[i]][[1]])
    cat("/n/n ---------------------------------------/n/n")
  }
}

extract_results(nested_data, comp_type = "groupDiff")

```



First of all, the new format might be great because some variables, like group, could be extracted automatically?
- Think about which function arguments are really necessary. Something like state_var could be just checked and renamed externally?
- Maybe use long format for plotting? --> Problem, because later on it gets very complex, and I'm not sure everything can be solved with grouping. (maybe keep in mind, but don't try for now)
- naming the columns might be problematic --> label column?
- In the end, I had a list of dataframes that contained different dataframes for different parts of the plots. 
- It might be, that the data preperation was too complicated. But what I had in the end were dataframes with one row per group/country, and the values in different columns behind. 
- I now have each group just once (which is great already)! The according estimates only have to be added as extra columns. 
- Need good documentation of column names. 


## Requirements on prepared data
- One row per group
- One column per estimate
- different data frames for different aspects of the plot

## Open questions about data
- NAs in group data frame
- parameter column = 1 in estiamtes
- Verschachtelte, unbenannte Listen, v.a. im letzten Datensatz
- Darf ich die Datens√§tze als Examples hochladen?
